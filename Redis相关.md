# Redis相关

## 1.Redis的数据结构

**首先Redis的常用的几种数据结构：5+3**

String、List、Hash、Set、ZSet、BitMap、GEO、hyperloglog

String 类似 java中的Map，存储的就是k，v 有个加减1的操作

List是双端列表，比如微信的公众号消息或者评论

Hash相当于Java的Map<String,Map<Objeetc,Object>>，value是一个对象，比如如果实现一个类似购物车的功能

Set：不允许重复，可以随机弹出元素

ZSet：每个元素都会有一个分数，可以排名

BitMap：存储的01 二进制数组

hyperloglog：用于一些基数统计（不包含）DAU 日活

GEO地理位置：

- 将三维的地球变为二维的坐标
- 在将二维的坐标转换为一维的点块
- 最后将一维的点块转换为二进制再通过base32编码

**其次，每种数据类型其实在redis的底层是不区分的，有一个共同的RedisObject对象**

<img src=".\Redis相关.assets\image-20240901151334018.png" alt="image-20240901151334018" style="zoom: 50%;" />

redisObject的结构体里面，有一个type字段，用来区分string、list、hash、set、zset

其中还有一个 *ptr 指针，这个指针指向的是真正存储数据的地方

**下面依次说一下几种数据类型的真正数据结构**

String类型，String有三种方式存储

- int 保存在long的64位范围内的整数

- embstr 数据就存储在ptr指针的下面 字符串长度小于44

- SDS（简单动态字符串） ptr指向指向的就是SDS的结构体

  <img src=".\Redis相关.assets\image-20240901152005465.png" alt="image-20240901152005465" style="zoom: 25%;" />

Hash类型，有两种存储方法：压缩列表（ziplist）和哈希表（HashTable）

[Redis：hash类型底层数据结构剖析-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1346861)

压缩列表本质上就是字节数组，一堆01，会将存储的内容编码

<img src=".\Redis相关.assets\image-20240901152455513.png" alt="image-20240901152455513" style="zoom:25%;" />

主要是通过记录上一个entry的长度，通过长度的计算获取下一个元素，不是使用链表的pre和next

HashTable的底层数据结构：字典

ptr指向会指向一个字典

**每个哈希表节点保存一个键值对，每个哈希表由多个哈希表节点构成，而字典则是对哈希表的进一步封装**。

<img src="E:\aaa找工作\秋招\Redis相关.assets\image-20240901152956085.png" alt="image-20240901152956085" style="zoom: 50%;" />

其中，dict代表字典，dictht代表哈希表，dictEntry代表哈希表节点。可以看出，dictEntry是一个数组，这很好理解，因为一个哈希表里要包含多个哈希表节点。而dict里包含2个dictht，多出的哈希表用于REHASH。

// ReHash的过程-大致需要看一下

List的底层数据结构：quckList快速链表 LinkedList + zipList

<img src=".\Redis相关.assets\image-20240901162245016.png" alt="image-20240901162245016" style="zoom:33%;" />

Set的底层数据结构：inset和hashTable

inyset存储整数的结构体

hashtable字典

Zset的数据结构：zipList和skipList

<img src="E:\aaa找工作\秋招\Redis相关.assets\image-20240901162905504.png" alt="image-20240901162905504" style="zoom: 33%;" />

利用类似二分查找，建立冗余索引，时间复杂度为logn

为什么不使用B+树：

- 设计的目的不同：MySQL中，为了减少磁盘的IO次数，需要存储的树尽量的低，三层b+树是可以索引千万级别的数据，b+树的插入和删除都会涉及树的分裂和合并，redis就是在内存中，不在意查询的次数，不需要考虑树的平衡，需要简单的设计即可
- 占用空间：B+树的指针管理和实现都比跳表复杂
- 1，时间复杂度方面：大部分情况下，跳跃表的效率和平衡树媲美；
  2，算法实现方面：跳跃表的实现比平衡树、b+树更为简单；
  <img src="https://i-blog.csdnimg.cn/blog_migrate/30de678fc87cf5c454562518bc8e0d00.png" alt="image-20230219184543704" style="zoom:50%;" />

## 2.Redis实现分布式锁

### 2.1 单机分布式锁

锁的分类：

- 单机锁：同一个JVM虚拟机内，synchronized或者lock接口
- 分布式锁：锁不同的JVM虚拟机，单机锁不起作用，资源类在不同的服务器之间共享

普通的redis锁的加锁过程：

1.最简单的版本

set if not exist，如果存在key设置失败

```mysql
setnx key value 
```

存在的问题：持有锁的服务崩了，导致一直无法释放锁

2.使用Redis自带的原子命令,增加设置锁的过期时间：

```mysql
setnx key value nx ex 100
```

这个命令的作用如下：

- `SETNX key value`：如果 `key` 不存在，则设置 `key` 的值为 `value`。
- `NX`：此选项确保只有在 `key` 不存在的情况下才执行设置操作。
- `EX 100`：设置 `key` 的过期时间为 100 秒。

3.过期时间的设置和删掉别人的锁

对应的解决办法

- 锁的续约，看门狗机制
- 每个锁区分一下，保证锁不会被误删 UUID

4.判断锁是否属于自己和删除锁之间没有原子

<img src="./Redis相关.assets/image-20240905184708844.png" alt="image-20240905184708844" style="zoom: 50%;" />

5.使用LUA脚本，保证判断和删除都是原子性的

```lua
"if redis.call('get', KEYS[1]) == ARGV[1] " +
"then " +
"return redis.call('del', KEYS[1]) " +
"else " +
"   return 0 " +
"end";
```

总结：

- **主要通过setnx方式，设置一个有过期时间并且和客户端相关的独特key**
- **解锁的过程：主要通过Lua脚本保证判断和删除操作的原子性，以此保证只能删除自己的锁。**

### 2.2 Redisson

单机版还有无法解决的问题，

- 单机的redis直接挂掉，主从也无法解决 线程1先获得锁，将对应的key-value写入主机 master 在主机将该键值对同步到从机slave之前,发生故障

  redis触发转移，将其中一个slave设置为新的master 但是此时新的master根本不包含线程1的key-value 线程2这时候来获取锁，发现没有加锁。获取锁成功。

- 锁的过期时间的限制

基于Redission的分布式锁：

Redission是基于 **Redlock 的算法，是RedLock算法的Java实现**

**解决上述的主从问题**：Redission直接将所有的从机全部变为主机，一个加锁的key由多个redis客户端去维护，它会对集群中的每个 Redis，**挨个去执行设置 Redis 锁的脚本**，也就是集群中的每个 Redis 都会包含设置好的锁数据。

例如：将三个redis客户端全部设置为master，同时加锁。如果有一个出现意外，去其余两个获取锁。完成分布式多机锁。

**对于解决设置锁过期时间：通过看门狗机制**

客户端加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端还持有锁key，那么就会不断的延长锁key的生存时间，默认每次续命从30秒新开始 当30秒结束之后线程还没有续约，锁自动释放。避免了死锁的产生。

<img src="./Redis相关.assets/image-20240905201639663.png" alt="image-20240905201639663" style="zoom:50%;" />

## 3.Redis的内存管理



## 4.缓存击穿、穿透、雪崩

### 4.1 缓存击穿：

> redis中原来有，突然失效，然后大量的请求打到数据库上面去，热点缓存失效，暴打MySQL

**互斥更新：参考单例模式双端检索，锁的方式**

分布式锁场景，在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

这种现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。

其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

这个就很危险，超高并发下这个短暂的过程足已让千千万万请求投向数据库。**更别提这可能是个慢查询，整个过程可能长达2s以上，那对数据库是一种非常大的伤害。**

redis中没有的时候，开始去数据库查找，访问数据库的时候添加一个互斥锁，在锁里面继续再次查询一次redis，其余的线程无法拿到锁，进行等待，当抢到锁的线程，再将数据回写Redis

<img src="./Redis相关.assets/image-20240905212541278.png" alt="image-20240905212541278" style="zoom:50%;" />

**空初始值，短暂的局部降级**

第一个请求将缓存的key对应的value设置为默认值或者空值

从数据库检索到数据的时候，放回更新到缓存当中。中间可能有一些请求获取到不正确的信息，但是总体保证了系统的稳定性

<img src="https://img2020.cnblogs.com/blog/167509/202109/167509-20210915212157689-1123025800.png" alt="img" style="zoom: 33%;" />

### 4.2 缓存穿透：

> redis中本来就没有，每次都要去数据库中查询，redis成为摆设
>
> 疯狂模拟一些不存在的`Key`，让你进入数据库去取数，这样就可以拖垮你的数据库，实现击溃你系统的目的。

**1.缓存空值**

key的值设置为null，并写到缓存池中。后面再出现查询这个key 的请求的时候，直接返回null，这样就在缓存池中就被判断返回了，压力在缓存层中，不会转移到数据库上。

**2.业务层判断key是否符合要求，先过滤无效的key，**

**3.使用布隆过滤器**

选择解决的角度：

- key非常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用 BloomFilter 直接过滤掉。
- 于空数据的key有限的，重复率比较高的，我们则可以采用 缓存空值的办法进行处理。 

布隆过滤器的原理

// TODO

### 4.3 缓存雪崩：

> 1.缓存雪崩是指大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。
>
> 2.redis突然崩溃

**1.缓存集群+数据库的集群**

数据库的读写分离，一主N从

**2.适当的限流和降级**

 Google的RateLimiter 限流

常见的限流算法：// TODO

Google的RateLimiter 都是不错的选择。

**3.差异化更新时间**

n * 3/4 + n * random() 。所以，比如你原本计划对一个缓存建立的过期时间为8小时，那就是6小时 + 0~2小时的随机值。
这样保证了均匀分布在 6~8小时之间

### 4.4 高QPS防范

**流量的削峰-消息队列：将并发的请求转变为串行**

这时候关心是不是及时拿回正确数据已经不重要了，保住你的缓存和数据库不被击穿才是关键。
队列的目的是让并行变成串行，这一定程度上降低系统处理用户请求的吞吐能力，但是却能很好的缓解你服务的压力和风险。

<img src="https://img2024.cnblogs.com/blog/167509/202403/167509-20240317084539764-1058552710.png" alt="image" style="zoom: 50%;" />

**集群模式和自动扩缩容模式**

从服务到缓存到数据层都应该具备，否则无法根据流量来进行弹性伸缩，保持高可用。
如下图， 蓝色部件是扩容的部分，每一分层都有自己的动态扩容机制。

## 5.缓存双写一致性

缓存和数据库追求的是最终一致性，肯定会出现缓存不一致的情况。

缓存-数据库的双写

- 更新缓存，更新数据库
  - 直接pass
- 先删缓存，在更新数据库
  - 导致缓存删不干净，线程A更新数据库的同时，线程B读取数据库的旧值，写入数据库，导致Redis是旧值。
  - 解决办法：
    - 延迟双删，写完db成功之后再次删除db中的值
- 先更新数据库，在删除缓存

使用异步的方式，类似MySQL的主从复制，通过监听Binlog日志，解析Binlog日志，异步更新缓存

<img src="./Redis相关.assets/image-20240905202623313.png" alt="image-20240905202623313" style="zoom: 50%;" />
